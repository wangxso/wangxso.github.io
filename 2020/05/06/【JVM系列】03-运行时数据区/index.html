<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【JVM系列】03-运行时数据区 · 非典型程序员的一生</title><meta name="description" content="【JVM系列】03-运行时数据区 - wangxso"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://wangxso.github.io/atom.xml" title="非典型程序员的一生"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="非典型程序员的一生" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/xxx" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangxso" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【JVM系列】03-运行时数据区</h1><div class="post-info">May 6, 2020</div><div class="post-content"><h2 id="1-运行时数据区的结构"><a href="#1-运行时数据区的结构" class="headerlink" title="1. 运行时数据区的结构"></a>1. 运行时数据区的结构</h2><p><img src="https://wangxblog.oss-cn-hangzhou.aliyuncs.com/usr/uploads/2020/05/1729374742.png"><br>每个JVM只对应一个Runtime实例</p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p>JVM虚拟机允许一个应用程序创建多个线程并行执行<br>在HotSpot JVM中，每个线程都和本地操作系统本地线程进行直接的映射</p>
<h2 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3.程序计数器"></a>3.程序计数器</h2><p>1).什么是程序计数器？</p>
<blockquote>
<p>JVM中的PC寄存器是物理机器上的PC寄存器的一个模拟,存放下一条指令的位置</p>
</blockquote>
<p>2).作用</p>
<blockquote>
<p>存储下一条指令的地址<br> ps:线程私有的,无GC，无OOM，其中native方法在PC中为undefined</p>
</blockquote>
<p>3)常见面试问题</p>
<ul>
<li><p>使用PC寄存器存储字节码指令地址有什么用?</p>
<blockquote>
<p>因为CPU在不断的切换进程，用PC寄存，就能在切换回来的时候知道从哪里继续执行程序</p>
</blockquote>
</li>
<li><p>为什么PC寄存器是线程私有的</p>
<blockquote>
<p>若不是私有的就会导致指令错乱,可能在CPU切换的时候运行别人的指令</p>
</blockquote>
</li>
</ul>
<h2 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4.虚拟机栈"></a>4.虚拟机栈</h2><p>1).什么是虚拟机栈?</p>
<blockquote>
<p>主管Java程序的运行，它保存方法的局部变量，部分结果并参与方法的调用和返回</p>
</blockquote>
<p>2).栈帧</p>
<blockquote>
<p>虚拟机栈的基本单位，一个栈帧对于一个方法<br>ps: 虚拟机栈是线程私有的</p>
</blockquote>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接(指向运行时常量池的方法引用)</li>
<li>方法返回地址(方法正常退出或异常退出的定义)</li>
</ul>
<p>3).开发中遇到那些异常?</p>
<blockquote>
<p>允许设置Java栈为固定值，若超过设置的最大容量就会发送StackOverflowError<br>若动态添加，在扩容内存大于能分配的内存的时候就会产生OutOfMemoryError</p>
</blockquote>
<p>4)设置参数</p>
<blockquote>
<p>-Xss 设置最大的栈大小<br>如-Xss 256k,默认大小约为linux 1024KB Mac 1024KB</p>
</blockquote>
<p>5). 一些附加信息</p>
<blockquote>
<p>①.局部变量表<br> 定义一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据包括基本数据类型，对象引用以及returnaddress类型，在编译时就确定下来了，不存在数据安全问题<br> 最基本的单位slot，32位以内的数据类型只占用一个slot，64位的占用2个slot<br> 在构造方法或者实例方法中会将对象引用this存放在index为0的slot中，其余参数按照顺序排序。<br> slot可以重复利用，局部变量使用前必须显式赋值</p>
</blockquote>
<p> <strong><font color="red">局部变量表是重要的GCRoot，只要被局部变量表直接或者间接引用的变量不会被GC回收</font></strong></p>
<blockquote>
<p>②.操作数栈<br> 基本单位为栈深度，数组实现的栈<br> 栈顶缓存技术，缓存在cpu的寄存器，降低内存的IO次数，提升执行引擎的效率</p>
</blockquote>
<blockquote>
<p>③.动态链接<br> 在JVM中，将符号引用转换为调用方法的直接引用与方法绑定机制有关。</p>
</blockquote>
<ul>
<li>动态链接<br>  只是在运行时可知，对应的方法绑定机制为:早期绑定和晚期绑定，绑定时一个字段、方法或者类的符号引用呗替换为直接引用的过程，这仅仅发生一次<ul>
<li>早期绑定(如调用父类构造器)<br> 目标方法在编译器可知，在运行期不变</li>
<li>晚期绑定(如父类调用方法等)<br>与之相反</li>
</ul>
</li>
<li>静态链接<br> 一个字节码文件被转载如虚拟机时，如果被调用目标方法在编译器可知</li>
</ul>
<p><strong>具备多态性就具有早期绑定和晚期绑定两种方法</strong></p>
<h2 id="5-虚方法和非虚方法"><a href="#5-虚方法和非虚方法" class="headerlink" title="5.虚方法和非虚方法"></a>5.虚方法和非虚方法</h2><p>1).非虚方法:方法在编译期间就确定好了调用版本，这个版本运行时是不可变的<br>  如：静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法<br>2).虚方法<br>其他方法均称为虚方法</p>
<h2 id="6-方法重写的本质"><a href="#6-方法重写的本质" class="headerlink" title="6.方法重写的本质"></a>6.方法重写的本质</h2><p>step1.找到操作数栈栈顶的第一个元素所执行的对象实际类型记为C<br>step2.若类型C中找到常量中的描述符合并且简单名称都符合的方法，则进行访问权限校验，如果通过返回这个方法的直接引用，查找过程结束<br>step3.否则按照继承关系从下往上一次对各个父类进行搜索和验证过程<br>step4.始终未找到，则抛出java.lang.AbstarctMethodError</p>
<p><font color='red'>每次调用都会进行这么一个过程，为了提升性能，JVM在类中方法区建立一个虚方法表，来用索引代替查找</font></p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>1）作用</p>
<blockquote>
<p>存放该方法PCC寄存器的值</p>
</blockquote>
<p>2).方法结束的方式</p>
<blockquote>
<p>①正常执行完成<br>②出现未处理的异常</p>
</blockquote>
<p> 无论哪种方式退出在方法退出后都会返回到该方法被调用的位置，方法正常退出，调用者的PC寄存器的值作为返回地址，即调用下一条指令的地址。而异常退出，返回地址是通过异常表确定的，栈帧中一般不会保存这部分信息</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/07/27/%E5%BB%BA%E5%85%B4Zeta%20SSD(%E4%B8%BB%E6%8E%A7%20SM2246EN)%20%E5%A4%8D%E6%B4%BB%E8%AE%B0/" class="prev">PREV</a><a href="/2020/04/08/%E3%80%90JVM%E7%B3%BB%E5%88%97%E3%80%9102-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2023 <a href="https://wangxso.github.io">wangxso</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"G-51FZKV3KE9",'auto');ga('send','pageview');</script></body></html>